<!DOCTYPE html>
<html lang="en" :data-bs-theme="currentTheme">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Ethereum Wallet (Testing Only)</title>
    <link rel="stylesheet" href="libs/bootstrap-5.3.3.min.css">
    <link rel="stylesheet" href="libs/bootstrap-icons-1.11.3.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="libs/ethers-6.13.5-ethers.umd.min.js"></script>
    <script src="libs/vue-3.5.13-vue.global.prod.min.js"></script>
</head>
<body>
    <!-- Vue App Root -->
    <div id="app" v-cloak>
        <!-- Header - Full width, content aligned to page edges -->
        <header class="mb-4 p-2 bg-info-subtle d-flex justify-content-between align-items-center">
            <h1 class="h3 mb-0"><i class="bi bi-currency-exchange me-2"></i>Ethereum Wallet (Testing Only)</h1> 
            <span class="theme-toggle" @click="toggleTheme" style="cursor: pointer;">
                <i :class="['bi', currentTheme === 'dark' ? 'bi-moon-stars-fill' : 'bi-sun-fill']"></i>
            </span>
        </header>

        <div class="container"> <!-- Main content container starts here -->
            <!-- Alert Placeholder -->
            <div id="alert-placeholder">
                 <transition-group name="alert-fade" tag="div">
                     <div v-for="alert in alerts" :key="alert.id" :class="['alert', 'alert-' + alert.type, 'alert-dismissible', 'fade', 'show']" role="alert">
                        <div>{{ alert.message }}</div>
                        <button type="button" class="btn-close" @click="dismissAlert(alert.id)" aria-label="Close"></button>
                    </div>
                </transition-group>
            </div>

            <!-- Loading Overlay -->
            <div class="loading-overlay" v-show="isLoading">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>

            <!-- Main Wallet View (Tabs) -->
            <div id="main-wallet-view">
                <!-- Nav tabs -->
                <ul class="nav nav-pills nav-fill mb-3" id="walletTab" role="tablist">
                  <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="wallet-tab" data-bs-toggle="tab" data-bs-target="#wallet-tab-pane" type="button" role="tab" aria-controls="wallet-tab-pane" aria-selected="true"><i class="bi bi-wallet2 me-1"></i> Wallet</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="transfer-tab" data-bs-toggle="tab" data-bs-target="#transfer-tab-pane" type="button" role="tab" aria-controls="transfer-tab-pane" aria-selected="false" :disabled="!isWalletInitialized"><i class="bi bi-send me-1"></i> Send</button>
                  </li>
                  <li class="nav-item" role="presentation">
                    <button class="nav-link" id="receive-tab" data-bs-toggle="tab" data-bs-target="#receive-tab-pane" type="button" role="tab" aria-controls="receive-tab-pane" aria-selected="false" :disabled="!isWalletInitialized"><i class="bi bi-qr-code me-1"></i> Receive</button>
                  </li>
                </ul>

                <!-- Tab panes -->
                <div class="tab-content" id="walletTabContent">
                  <!-- Wallet Pane -->
                  <div class="tab-pane fade show active" id="wallet-tab-pane" role="tabpanel" aria-labelledby="wallet-tab" tabindex="0">

                       <!-- Network & RPC Card -->
                       <div class="card shadow-sm mb-4">
                           <div class="card-body">
                                <h5 class="card-title mb-3"><i class="bi bi-cloud-arrow-up me-1"></i> Network & RPC Configuration</h5>
                                <div class="mb-3">
                                    <label for="network-select" class="form-label">Network</label>
                                    <select class="form-select mb-2" id="network-select" v-model="selectedNetwork" @change="updateRpcEndpoint">
                                        <option v-for="network in availableNetworks" :key="network.id" :value="network.id">
                                            {{ network.name }}
                                        </option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label for="rpc-endpoint" class="form-label">RPC Endpoint URL</label>
                                    <input type="text" class="form-control" id="rpc-endpoint" v-model="rpcEndpoint" 
                                        :readonly="selectedNetwork !== 'custom'"
                                        :class="selectedNetwork !== 'custom' ? 'bg-secondary-subtle' : ''">
                                </div>
                                <!-- Network status display -->
                                <small :class="networkStatusClass">{{ networkStatusText }}</small>
                           </div>
                       </div>

                      <!-- Manage Wallet Session Card -->
                      <div class="card shadow-sm mb-4">
                           <div class="card-body">
                               <h5 class="card-title mb-3"><i class="bi bi-key-fill me-1"></i> Manage Wallet Session</h5>

                               <!-- Create/Import Section -->
                                <div v-if="showWalletManagement">
                                    <div class="mb-3">
                                        <button class="btn btn-primary" @click="generateNewWallet"><i class="bi bi-plus-circle me-1"></i> Generate New Wallet</button>
                                    </div>
                                    <div class="mb-3">
                                        <label for="seed-input" class="form-label">Seed Phrase or Private Key</label>
                                         <div class="input-group">
                                             <input :type="seedVisible ? 'text' : 'password'" class="form-control" id="seed-input" 
                                                    placeholder="Enter seed phrase or private key" v-model="seedPhrase" @keydown.enter="initializeWallet">
                                             <button class="btn btn-outline-secondary" type="button" @click="toggleSeedVisibility" title="Show/Hide Key">
                                                <i :class="['bi', seedVisible ? 'bi-eye-slash-fill' : 'bi-eye-fill']"></i>
                                             </button>
                                             <button class="btn btn-success" type="button" @click="initializeWallet" :disabled="!seedPhrase" title="Import Wallet">
                                                <i class="bi bi-box-arrow-in-right me-1"></i> Import
                                             </button>
                                         </div>
                                    </div>
                                </div>

                               <!-- Loaded Wallet Info Section -->
                                <div v-if="showLoadedWalletDetails" class="mt-4 border-top pt-3">
                                    <div class="mb-3">
                                         <label class="form-label">Current Session Key:</label>
                                         <div class="input-group">
                                             <span class="form-control private-key-display" :class="{'text-muted': !isPrivateKeyVisible}">{{ currentPrivateKeyDisplay }}</span>
                                             <button class="btn btn-outline-secondary" type="button" @click="toggleCurrentPrivateKeyVisibility" title="Show/Hide Key">
                                                 <i :class="['bi', isPrivateKeyVisible ? 'bi-eye-slash-fill' : 'bi-eye-fill']"></i>
                                             </button>
                                             <button class="btn btn-outline-secondary" type="button" @click="copyPrivateKey" title="Copy Private Key">
                                                 <i class="bi bi-clipboard"></i>
                                            </button>
                                         </div>
                                         <small class="text-danger">Never share your private key or seed phrase!</small>
                                    </div>
                                    <button class="btn btn-danger btn-sm" @click="clearSession"><i class="bi bi-x-octagon me-1"></i> Clear Wallet Session</button>
                               </div>

                               <div v-if="error" class="alert alert-danger mt-3">
                                   <i class="bi bi-exclamation-triangle me-2"></i>{{ error }}
                               </div>
                           </div>
                      </div>

                      <!-- Wallet Details (when wallet is loaded) -->
                      <div class="card shadow-sm mb-4" v-if="isWalletInitialized">
                          <div class="card-body">
                              <h5 class="card-title mb-3"><i class="bi bi-info-circle me-1"></i> Wallet Details</h5>
                              <!-- Account Cards -->
                              <div v-for="account in accounts" :key="account.address" class="mb-3">
                                 <div class="input-group">
                                      <span class="form-control address-display">{{ account.address }} ({{ Number(parseFloat(Number(account.balance).toFixed(4))) }} {{ chainInfo?.nativeSymbol }})</span>
                                      <button class="btn btn-outline-secondary" type="button" @click="copyAddress(account.address)" title="Copy Address">
                                          <i class="bi bi-clipboard"></i>
                                     </button>
                                 </div>
                         </div>
                      </div>
                   </div>

                  </div>

                  <!-- Send Pane -->
                  <div class="tab-pane fade" id="transfer-tab-pane" role="tabpanel" aria-labelledby="transfer-tab" tabindex="0">
                      <div class="card shadow-sm" v-if="isWalletInitialized">
                        <div class="card-body">
                             <h5 class="card-title mb-3"><i class="bi bi-send-fill me-1"></i> Send Transaction</h5>

                             <div class="mb-3">
                                 <label class="form-label">From Address:</label>
                                 <select class="form-select" v-model="selectedFromAddress" @change="updateTokenBalance">
                                    <option value="">Select sending address</option>
                                    <option v-for="account in accounts" :key="account.address" :value="account.address">
                                        {{ account.address }} ({{ Number(parseFloat(Number(account.balance).toFixed(4))) }} {{chainInfo.nativeSymbol}})
                                    </option>
                                </select>
                             </div>

                             <div class="mb-3">
                                 <label class="form-label">Token Type:</label>
                                 <select class="form-select" v-model="tokenType">
                                    <option :value="'native'">{{ chainInfo?.nativeSymbol || 'Native Token' }}</option>
                                    <option value="erc20">ERC20 Token</option>
                                </select>
                             </div>

                             <div v-if="tokenType === 'erc20'" class="mb-3">
                                <label class="form-label">ERC20 Token Contract Address:</label>
                                <div class="input-group">
                                    <input class="form-control" v-model="tokenAddress" placeholder="Enter token contract address" @input="updateTokenBalance">
                                    <div v-if="tokenInfo" class="input-group-text">
                                        Balance: {{ tokenInfo.balance }} {{ tokenInfo.symbol }}
                                    </div>
                                </div>
                             </div>

                             <div class="mb-3">
                                 <label for="to-address" class="form-label">To Address</label>
                                 <input type="text" class="form-control" id="to-address" v-model="toAddress" placeholder="Enter recipient address">
                             </div>

                             <div class="mb-3">
                                 <label for="amount" class="form-label">Amount</label>
                                 <input type="number" step="any" class="form-control" id="amount" v-model="amount" placeholder="Enter amount">
                             </div>

                             <div class="mb-3" v-if="estimatedGas">
                                <div class="alert alert-info">
                                    <strong>Gas Cost:</strong> {{ estimatedGas.ethCost }} {{ chainInfo?.nativeSymbol }}
                                    <br><small>(Including 20% buffer for safety)</small>
                                </div>
                             </div>

                             <button class="btn btn-success" @click="sendTransaction" :disabled="isLoading">
                                <i class="bi bi-send-check me-1"></i> Send Transaction
                             </button>

                             <div v-if="txStatus" class="alert alert-success mt-3">
                                <strong>Transaction Status:</strong> {{ txStatus }}
                             </div>
                        </div>
                    </div>
                     <div class="alert alert-warning" v-else>
                         Please initialize a wallet first to send transactions.
                     </div>
                  </div>

                  <!-- Receive Pane -->
                  <div class="tab-pane fade" id="receive-tab-pane" role="tabpanel" aria-labelledby="receive-tab" tabindex="0">
                      <div v-if="isWalletInitialized">
                        <!-- Receive Cards for each account -->
                        <div v-for="account in accounts" :key="account.address" class="card shadow-sm mb-4">
                            <div class="card-body text-center">
                                <h5 class="card-title mb-3"><i class="bi bi-arrow-down-circle me-1"></i> Receive {{ chainInfo?.nativeSymbol || 'ETH' }}</h5>
                                <p>Share this address or QR code to receive funds:</p>
                                                                 <div class="input-group mb-3 w-auto mx-auto" style="max-width: 500px;">
                                     <span class="form-control form-control-lg address-display">{{ account.address }}</span>
                                      <button class="btn btn-outline-secondary" type="button" @click="copyAddress(account.address)" title="Copy Address">
                                          <i class="bi bi-clipboard"></i>
                                      </button>
                                 </div>
                                <!-- Balance display -->
                                <div class="mb-3">
                                    <small class="text-muted">Current Balance: </small>
                                    <span class="fw-bold">{{ Number(parseFloat(Number(account.balance).toFixed(4))) }} {{ chainInfo?.nativeSymbol }}</span>
                                </div>
                                <!-- QR Code Container -->
                                <div class="qr-code-container" :data-qr-address="account.address"></div>
                            </div>
                        </div>
                      </div>
                      <div class="alert alert-warning" v-else>
                          Please initialize a wallet first to view receive addresses.
                      </div>
                  </div>
                </div>
            </div>

        </div> <!-- /container -->
    </div> <!-- /app -->

    <!-- JS Includes -->
    <script src="libs/bootstrap-5.3.3.bundle.min.js"></script>
    <!-- Add QR Code Library -->
    <script src="libs/qrcode-1.0.0.min.js"></script>
    
    <script>
        const ERC20_ABI = [
            "function balanceOf(address owner) view returns (uint256)",
            "function decimals() view returns (uint8)",
            "function symbol() view returns (string)",
            "function name() view returns (string)",
            "function transfer(address to, uint amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "function approve(address spender, uint256 amount) returns (bool)"
        ];

        const { createApp, ref, watch, onMounted, computed } = Vue;

        createApp({
            setup() {
                const currentTab = ref('Configuration');
                const tabs = ['Configuration', 'Accounts', 'Transfer'];
                const selectedNetwork = ref('base');
                const rpcEndpoint = ref('https://mainnet.base.org');
                const seedPhrase = ref('');
                const seedVisible = ref(false);
                
                // Available networks with their RPC endpoints
                const availableNetworks = ref([
                    {
                        id: 'ethereum',
                        name: 'Ethereum Mainnet',
                        rpcUrl: 'https://eth.drpc.org'
                    },
                    {
                        id: 'sepolia',
                        name: 'Sepolia Testnet',
                        rpcUrl: 'https://1rpc.io/sepolia'
                    },
                    {
                        id: 'base',
                        name: 'Base',
                        rpcUrl: 'https://mainnet.base.org'
                    },
                    {
                        id: 'optimism',
                        name: 'Optimism',
                        rpcUrl: 'https://mainnet.optimism.io'
                    },
                    {
                        id: 'polygon',
                        name: 'Polygon',
                        rpcUrl: 'https://polygon-rpc.com'
                    },
                    {
                        id: 'arbitrum',
                        name: 'Arbitrum One',
                        rpcUrl: 'https://arb1.arbitrum.io/rpc'
                    },
                    {
                        id: 'custom',
                        name: 'Custom',
                        rpcUrl: ''
                    }
                ]);
                const walletStatus = ref('');
                const error = ref('');
                const accounts = ref([]);
                const selectedFromAddress = ref('');
                const tokenType = ref('native');
                const chainInfo = ref(null);
                const tokenAddress = ref('');
                const toAddress = ref('');
                const amount = ref('');
                const txStatus = ref('');
                const estimatedGas = ref('');
                const tokenInfo = ref(null);

                // New state for Bootstrap styling
                const currentTheme = ref('dark');
                const isLoading = ref(false);
                const alerts = ref([]);
                const showWalletManagement = ref(true);
                const showLoadedWalletDetails = ref(false);
                const networkStatusText = ref('');
                const networkStatusClass = ref('form-text text-muted d-block mt-2');
                const isPrivateKeyVisible = ref(false);
                const currentPrivateKey = ref('');
                const originalSeedInput = ref(''); // Store the original input (seed phrase or private key)

                let provider = null;
                const wallets = ref([]);
                const walletPrivateKeys = [];
                const isWalletInitialized = ref(false);
                let allowedRpcEndpoint = null;

                onMounted(() => {
                    // Initialize theme
                    document.documentElement.setAttribute('data-bs-theme', currentTheme.value);
                    updateWalletStateUI();
                    networkStatusText.value = `Selected Network: ${getNetworkName()} (Default)`;
                    networkStatusClass.value = 'form-text text-primary d-block mt-2';
                    
                    // Listen for Receive tab being shown to generate QR codes
                    const receiveTabTrigger = document.getElementById('receive-tab');
                    if (receiveTabTrigger) {
                        receiveTabTrigger.addEventListener('shown.bs.tab', event => {
                            if (isWalletInitialized.value) {
                                generateAllQRCodes();
                            }
                        });
                    }
                });

                const getNetworkName = () => {
                    const network = availableNetworks.value.find(n => n.id === selectedNetwork.value);
                    return network ? network.name : 'Unknown';
                };

                // Computed property for masked private key display
                const currentPrivateKeyDisplay = computed(() => {
                    if (!originalSeedInput.value || originalSeedInput.value.length < 10) return '***';
                    if (isPrivateKeyVisible.value) {
                        return originalSeedInput.value;
                    }
                    return `${originalSeedInput.value.substring(0, 6)}...${originalSeedInput.value.substring(originalSeedInput.value.length - 6)}`;
                });

                // Alert system
                const showAlert = (message, type = 'info') => {
                    const id = Date.now();
                    const newAlert = { message, type, id };
                    alerts.value = []; // Clear existing alerts
                    alerts.value.push(newAlert);

                    setTimeout(() => {
                        dismissAlert(id);
                    }, 4000);
                };

                const dismissAlert = (id) => {
                    if (id) {
                        alerts.value = alerts.value.filter(alert => alert.id !== id);
                    } else {
                        alerts.value = [];
                    }
                };

                // Theme toggle
                const toggleTheme = () => {
                    currentTheme.value = currentTheme.value === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-bs-theme', currentTheme.value);
                };

                const updateWalletStateUI = () => {
                    showWalletManagement.value = !isWalletInitialized.value;
                    showLoadedWalletDetails.value = isWalletInitialized.value;
                };

                const detectChainInfo = async () => {
                    // For known networks, use predefined information
                    if (selectedNetwork.value !== 'custom') {
                        const networkConfig = {
                            'ethereum': { name: 'Ethereum Mainnet', chainId: 1, nativeSymbol: 'ETH' },
                            'sepolia': { name: 'Sepolia Testnet', chainId: 11155111, nativeSymbol: 'ETH' },
                            'base': { name: 'Base', chainId: 8453, nativeSymbol: 'ETH' },
                            'optimism': { name: 'Optimism', chainId: 10, nativeSymbol: 'ETH' },
                            'polygon': { name: 'Polygon', chainId: 137, nativeSymbol: 'MATIC' },
                            'arbitrum': { name: 'Arbitrum One', chainId: 42161, nativeSymbol: 'ETH' }
                        };
                        
                        chainInfo.value = networkConfig[selectedNetwork.value] || { name: 'Unknown Chain', chainId: 0, nativeSymbol: 'ETH' };
                        return;
                    }
                    
                    // Only detect network for custom RPC endpoints
                    if (!provider) {
                        chainInfo.value = { name: 'Unknown Chain', chainId: 0, nativeSymbol: 'ETH' };
                        return;
                    }
                    
                    try {
                        const network = await provider.getNetwork();
                        const chainId = Number(network.chainId);

                        const chainToSymbol = {
                            1: 'ETH',      // Ethereum Mainnet
                            11155111: 'ETH', // Sepolia Testnet
                            137: 'MATIC',  // Polygon
                            56: 'BNB',     // BSC
                            43114: 'AVAX', // Avalanche
                            42161: 'ETH',  // Arbitrum
                            10: 'ETH',     // Optimism
                            8453: 'ETH',   // Base
                            324: 'ETH',    // zkSync Era
                            59144: 'ETH',  // Linea
                            100: 'XDAI',   // Gnosis Chain
                            42220: 'CELO', // Celo
                        };

                        chainInfo.value = {
                            name: network.name || 'Custom Network',
                            chainId: chainId,
                            nativeSymbol: chainToSymbol[chainId] || 'ETH'
                        };
                    } catch (err) {
                        console.log('Network detection failed for custom RPC:', err.message);
                        chainInfo.value = { name: 'Custom Network (Detection Failed)', chainId: 0, nativeSymbol: 'ETH' };
                    }
                };

                const showError = (message) => {
                    error.value = message;
                    setTimeout(() => {
                        error.value = '';
                    }, 5000);
                };

                const toggleSeedVisibility = () => {
                    seedVisible.value = !seedVisible.value;
                };

                const toggleCurrentPrivateKeyVisibility = () => {
                    isPrivateKeyVisible.value = !isPrivateKeyVisible.value;
                };

                const copyPrivateKey = async () => {
                    if (!originalSeedInput.value) {
                        showAlert('No seed phrase or private key to copy', 'warning');
                        return;
                    }
                    try {
                        await navigator.clipboard.writeText(originalSeedInput.value);
                        const message = originalSeedInput.value.includes(' ') ? 'Seed phrase copied to clipboard!' : 'Private key copied to clipboard!';
                        showAlert(message, 'success');
                    } catch (err) {
                        showAlert('Failed to copy to clipboard', 'warning');
                    }
                };

                const clearSession = () => {
                    wallets.value.length = 0;
                    walletPrivateKeys.length = 0;
                    accounts.value.length = 0;
                    isWalletInitialized.value = false;
                    selectedFromAddress.value = '';
                    tokenInfo.value = null;
                    txStatus.value = '';
                    estimatedGas.value = '';
                    error.value = '';
                    walletStatus.value = '';
                    seedPhrase.value = '';
                    currentPrivateKey.value = '';
                    originalSeedInput.value = '';
                    isPrivateKeyVisible.value = false;
                    updateWalletStateUI();
                    showAlert('Wallet session cleared.', 'info');
                };

                const initializeWallet = async () => {
                    try {
                        if (!rpcEndpoint.value || !seedPhrase.value) {
                            throw new Error('Please provide both RPC endpoint and seed phrase');
                        }

                        isLoading.value = true;
                        allowedRpcEndpoint = rpcEndpoint.value;
                        
                        // Create provider with network info for known networks to avoid detection
                        if (selectedNetwork.value !== 'custom') {
                            try {
                                let networkInfo;
                                switch (selectedNetwork.value) {
                                    case 'ethereum':
                                        networkInfo = ethers.Network.from('mainnet');
                                        break;
                                    case 'sepolia':
                                        networkInfo = ethers.Network.from('sepolia');
                                        break;
                                    case 'base':
                                        networkInfo = ethers.Network.from({ name: 'base', chainId: 8453 });
                                        break;
                                    case 'optimism':
                                        networkInfo = ethers.Network.from({ name: 'optimism', chainId: 10 });
                                        break;
                                    case 'polygon':
                                        networkInfo = ethers.Network.from({ name: 'matic', chainId: 137 });
                                        break;
                                    case 'arbitrum':
                                        networkInfo = ethers.Network.from({ name: 'arbitrum', chainId: 42161 });
                                        break;
                                    default:
                                        networkInfo = null;
                                }
                                
                                if (networkInfo) {
                                    provider = new ethers.JsonRpcProvider(rpcEndpoint.value, networkInfo, { staticNetwork: networkInfo });
                                } else {
                                    provider = new ethers.JsonRpcProvider(rpcEndpoint.value);
                                }
                            } catch (err) {
                                console.log('Failed to create provider with network info, using default:', err.message);
                                provider = new ethers.JsonRpcProvider(rpcEndpoint.value);
                            }
                        } else {
                            provider = new ethers.JsonRpcProvider(rpcEndpoint.value);
                        }
                        wallets.value.length = 0;
                        walletPrivateKeys.length = 0;
                        accounts.value.length = 0;
                        isWalletInitialized.value = false;
                        
                        selectedFromAddress.value = '';
                        tokenInfo.value = null;
                        txStatus.value = '';
                        estimatedGas.value = '';
                        error.value = '';
                        walletStatus.value = 'Initializing wallet...';

                        // Store the original input (seed phrase or private key)
                        originalSeedInput.value = seedPhrase.value;
                        
                        if (seedPhrase.value.includes(' ')) {
                            // Seed phrase
                            for (let i = 0; i < 5; i++) {
                                const path = `m/44'/60'/0'/0/${i}`;
                                const derivedWallet = ethers.HDNodeWallet.fromMnemonic(
                                    ethers.Mnemonic.fromPhrase(seedPhrase.value),
                                    path
                                );
                                walletPrivateKeys.push(derivedWallet.privateKey);
                                
                                const connectedWallet = derivedWallet.connect(provider);
                                wallets.value.push(connectedWallet);
                            }
                            // Set the first wallet's private key as the current one
                            currentPrivateKey.value = walletPrivateKeys[0];
                        } else {
                            // Private key
                            walletPrivateKeys.push(seedPhrase.value);
                            currentPrivateKey.value = seedPhrase.value;
                            
                            const newWallet = new ethers.Wallet(seedPhrase.value, provider);
                            wallets.value.push(newWallet);
                        }
                        await detectChainInfo();
                        await refreshAccounts();
                        isWalletInitialized.value = true;
                        error.value = '';
                        updateWalletStateUI();
                        showAlert('Wallet initialized successfully!', 'success');

                    } catch (err) {
                        showError(err.message);
                        showAlert('Failed to initialize wallet: ' + err.message, 'danger');
                    } finally {
                        isLoading.value = false;
                    }
                };

                const refreshAccounts = async () => {
                    if (!provider || wallets.value.length === 0) {
                        showError('Please initialize wallet first');
                        return;
                    }

                    const walletsWithBalance = await Promise.all(
                        wallets.value.map(async (wallet) => {
                            const balance = await provider.getBalance(wallet.address);
                            return {
                                address: wallet.address,
                                balance: ethers.formatEther(balance)
                            };
                        })
                    );

                    accounts.value = walletsWithBalance.sort((a, b) =>
                        parseFloat(b.balance) - parseFloat(a.balance)
                    ).slice(0, 3);

                    if (wallets.value.length === 1) {
                        selectedFromAddress.value = wallets.value[0].address;
                        await updateTokenBalance();
                    }
                };

                const updateTokenBalance = async () => {
                    if (!selectedFromAddress.value) return;
                    tokenInfo.value = null;

                    if (tokenType.value === 'erc20' && tokenAddress.value) {
                        try {
                            const wallet = wallets.value.find(w => w.address === selectedFromAddress.value);
                            if (!wallet) return;
                            const contract = new ethers.Contract(tokenAddress.value, ERC20_ABI, wallet);
                            const balance = await contract.balanceOf(selectedFromAddress.value);
                            const decimals = await contract.decimals();
                            const symbol = await contract.symbol();
                            const name = await contract.name();
                            const formattedBalance = ethers.formatUnits(balance, decimals);
                            
                            tokenInfo.value = {
                                balance: Number(parseFloat(Number(formattedBalance).toFixed(4))),
                                symbol: symbol,
                                name: name
                            };
                        } catch (err) {
                            txStatus.value = 'Error fetching token balance: ' + err.message;
                        }
                    }
                };

                const updateGasEstimate = async () => {
                    if (!selectedFromAddress.value || !toAddress.value || !amount.value) {
                        estimatedGas.value = '';
                        return;
                    }

                    try {
                        const wallet = wallets.value.find(w => w.address === selectedFromAddress.value);
                        if (!wallet) return;

                        let gasEstimate;
                        if (tokenType.value === 'native') {
                            const txRequest = {
                                to: toAddress.value,
                                value: ethers.parseEther(amount.value.toString())
                            };
                            gasEstimate = await provider.estimateGas(txRequest);
                        } else {
                            if (!tokenAddress.value) return;
                            const contract = new ethers.Contract(tokenAddress.value, ERC20_ABI, wallet);
                            const decimals = await contract.decimals();
                            const transferTx = await contract.transfer.populateTransaction(
                                toAddress.value,
                                ethers.parseUnits(amount.value.toString(), decimals)
                            );
                            gasEstimate = await provider.estimateGas({
                                ...transferTx,
                                from: wallet.address
                            });
                        }

                        const gasWithBuffer = gasEstimate * 120n / 100n;
                        const feeData = await provider.getFeeData();
                        const gasPrice = feeData.gasPrice;
                        const totalCostWei = gasWithBuffer * gasPrice;
                        const totalCostEth = ethers.formatEther(totalCostWei);
                        const formattedCost = parseFloat(totalCostEth).toFixed(6);

                        estimatedGas.value = {
                            gasUnits: gasWithBuffer.toString(),
                            ethCost: `${formattedCost}`
                        };

                        txStatus.value = '';
                    } catch (err) {
                        estimatedGas.value = '';
                        if (txStatus.value === '') {
                            txStatus.value = 'Gas estimation failed: ' + err.message;
                        }
                    }
                };

                watch([selectedFromAddress, toAddress, amount, tokenType, tokenAddress],
                    async () => {
                        await updateGasEstimate();
                    }
                );

                const sendTransaction = async () => {
                    try {
                        if (!selectedFromAddress.value || !toAddress.value || !amount.value) {
                            throw new Error('Please fill in all fields');
                        }

                        isLoading.value = true;
                        const wallet = wallets.value.find(w => w.address === selectedFromAddress.value);
                        if (!wallet) throw new Error('Sender wallet not found');
                        
                        const walletIndex = wallets.value.findIndex(w => w.address === selectedFromAddress.value);
                        if (walletIndex === -1) throw new Error('Wallet not found');
                        
                        const rawPrivateKey = walletPrivateKeys[walletIndex];
                        if (!rawPrivateKey) throw new Error('Private key not found');
                        
                        const connectedWallet = new ethers.Wallet(rawPrivateKey, provider);

                        let tx;
                        if (tokenType.value === 'native') {
                            const txRequest = {
                                to: toAddress.value,
                                value: ethers.parseEther(amount.value.toString())
                            };

                            try {
                                const gasEstimate = await provider.estimateGas(txRequest);
                                txRequest.gasLimit = gasEstimate * 120n / 100n;
                            } catch (error) {
                                console.error('Gas estimation failed:', error);
                                throw new Error('Failed to estimate gas. Please check if you have sufficient funds for gas.');
                            }

                            tx = await connectedWallet.sendTransaction(txRequest);
                        } else {
                            if (!tokenAddress.value) throw new Error('Please provide token address');
                            const contract = new ethers.Contract(tokenAddress.value, ERC20_ABI, connectedWallet);
                            const decimals = await contract.decimals();

                            const transferTx = await contract.transfer.populateTransaction(
                                toAddress.value,
                                ethers.parseUnits(amount.value.toString(), decimals)
                            );

                            try {
                                const gasEstimate = await provider.estimateGas({
                                    ...transferTx,
                                    from: connectedWallet.address
                                });
                                transferTx.gasLimit = gasEstimate * 120n / 100n;
                            } catch (error) {
                                console.error('Gas estimation failed:', error);
                                throw new Error('Failed to estimate gas. Please check if you have sufficient funds and the token contract is valid.');
                            }

                            tx = await connectedWallet.sendTransaction(transferTx);
                        }

                        txStatus.value = `Transaction sent! Hash: ${tx.hash}`;
                        await tx.wait();
                        txStatus.value += ' (Confirmed)';
                        await refreshAccounts();

                    } catch (err) {
                        txStatus.value = 'Transaction failed: ' + err.message;
                    } finally {
                        isLoading.value = false;
                    }
                };

                const generateNewWallet = async () => {
                    try {
                        const wallet = ethers.Wallet.createRandom();
                        seedPhrase.value = wallet.privateKey;
                        
                        await initializeWallet();
                    } catch (err) {
                        showError('Failed to generate wallet: ' + err.message);
                        showAlert('Failed to generate wallet: ' + err.message, 'danger');
                    }
                };

                const copyAddress = async (address) => {
                    try {
                        await navigator.clipboard.writeText(address);
                        showAlert('Address copied to clipboard!', 'success');
                    } catch (err) {
                        showError('Failed to copy address to clipboard');
                        showAlert('Failed to copy address to clipboard', 'warning');
                    }
                };

                const getQRCodeUrl = (address) => {
                    const base64Address = btoa(address);
                    return `https://qrcode.sanjaysingh.net/?text=${base64Address}`;
                };

                const generateQRCode = (address, elementRef) => {
                    if (!elementRef || !address) return;
                    
                    // Clear any existing QR code
                    elementRef.innerHTML = '';
                    
                    try {
                        // Ensure QRCode library is available
                        if (typeof QRCode === 'undefined') {
                            console.error("QRCode library not loaded");
                            elementRef.textContent = 'Error: QR Code library not loaded.';
                            return;
                        }
                        
                        new QRCode(elementRef, {
                            text: address,
                            width: 256,
                            height: 256,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.H
                        });
                    } catch (e) {
                        console.error("Error generating QR code:", e);
                        elementRef.textContent = 'Error generating QR code.';
                    }
                };

                const generateAllQRCodes = () => {
                    // Use nextTick to ensure DOM is updated
                    Vue.nextTick(() => {
                        accounts.value.forEach(account => {
                            const qrElement = document.querySelector(`[data-qr-address="${account.address}"]`);
                            if (qrElement) {
                                generateQRCode(account.address, qrElement);
                            }
                        });
                    });
                };

                const updateRpcEndpoint = async () => {
                    const network = availableNetworks.value.find(n => n.id === selectedNetwork.value);
                    if (network && network.id !== 'custom') {
                        rpcEndpoint.value = network.rpcUrl;
                    }
                    
                    networkStatusText.value = `Selected Network: ${getNetworkName()}`;
                    networkStatusClass.value = 'form-text text-primary d-block mt-2';
                    
                    if (provider && wallets.value.length > 0 && seedPhrase.value) {
                        try {
                            await initializeWallet();
                        } catch (err) {
                            showError('Failed to switch network: ' + err.message);
                            showAlert('Failed to switch network: ' + err.message, 'danger');
                        }
                    }
                };

                return {
                    // Theme and UI state
                    currentTheme,
                    isLoading,
                    alerts,
                    showWalletManagement,
                    showLoadedWalletDetails,
                    networkStatusText,
                    networkStatusClass,
                    
                    // Private key state
                    isPrivateKeyVisible,
                    currentPrivateKey,
                    originalSeedInput,
                    currentPrivateKeyDisplay,
                    
                    // Original state
                    currentTab,
                    tabs,
                    selectedNetwork,
                    availableNetworks,
                    rpcEndpoint,
                    seedPhrase,
                    seedVisible,
                    walletStatus,
                    error,
                    accounts,
                    selectedFromAddress,
                    tokenType,
                    tokenAddress,
                    toAddress,
                    amount,
                    txStatus,
                    estimatedGas,
                    chainInfo,
                    tokenInfo,
                    isWalletInitialized,
                    
                    // Methods
                    toggleTheme,
                    showAlert,
                    dismissAlert,
                    toggleSeedVisibility,
                    toggleCurrentPrivateKeyVisibility,
                    copyPrivateKey,
                    clearSession,
                    initializeWallet,
                    updateTokenBalance,
                    sendTransaction,
                    generateNewWallet,
                    copyAddress,
                    getQRCodeUrl,
                    generateQRCode,
                    generateAllQRCodes,
                    updateRpcEndpoint
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
